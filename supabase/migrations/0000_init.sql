
-- Enable the uuid-ossp extension if not already enabled
create extension if not exists "uuid-ossp" with schema extensions;

-- Create the categories table
create table public.categories (
    id bigint generated by default as identity primary key,
    name text not null unique,
    created_at timestamp with time zone default now() not null
);
alter table public.categories enable row level security;
create policy "Allow public read access to categories" on public.categories for select using (true);
create policy "Allow admin full access to categories" on public.categories for all using (auth.uid() in (select id from public.profiles where is_admin = true)) with check (auth.uid() in (select id from public.profiles where is_admin = true));


-- Create the books table
create table public.books (
    id uuid default extensions.uuid_generate_v4() primary key,
    title text not null,
    description text,
    price numeric not null,
    thumbnail_url text,
    data_ai_hint text,
    preview_content text,
    full_content_url text,
    is_featured boolean default false not null,
    is_subscription boolean default false not null,
    tags text[],
    category_id bigint references public.categories(id) on delete set null,
    status text default 'draft'::text not null, -- 'published' or 'draft'
    seo_title text,
    seo_description text,
    created_at timestamp with time zone default now() not null,
    updated_at timestamp with time zone default now() not null
);
alter table public.books enable row level security;
create policy "Allow public read access to published books" on public.books for select using (status = 'published');
create policy "Allow admin full access to books" on public.books for all using (auth.uid() in (select id from public.profiles where is_admin = true)) with check (auth.uid() in (select id from public.profiles where is_admin = true));


-- Create the profiles table to extend auth.users
create table public.profiles (
    id uuid not null primary key references auth.users on delete cascade,
    full_name text,
    avatar_url text,
    phone_number text,
    is_admin boolean default false not null,
    balance numeric(10, 2) default 0.00 not null,
    updated_at timestamp with time zone default now() not null
);
alter table public.profiles enable row level security;
create policy "Allow public read access to basic profile info" on public.profiles for select using (true);
create policy "Allow users to update their own profile" on public.profiles for update using (auth.uid() = id);
create policy "Allow admin full access to profiles" on public.profiles for all using (auth.uid() in (select id from public.profiles where is_admin = true));

-- Function to create a profile for a new user
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, avatar_url, phone_number)
  values (
      new.id, 
      new.raw_user_meta_data->>'full_name', 
      new.raw_user_meta_data->>'avatar_url',
      new.phone
  );
  return new;
end;
$$;

-- Trigger to execute the function on new user creation
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- Create the user_books table for purchases
create table public.user_books (
    user_id uuid not null references public.profiles(id) on delete cascade,
    book_id uuid not null references public.books(id) on delete cascade,
    purchased_at timestamp with time zone default now() not null,
    primary key (user_id, book_id)
);
alter table public.user_books enable row level security;
create policy "Allow users to view their own purchased books" on public.user_books for select using (auth.uid() = user_id);
create policy "Allow admin read access to user_books" on public.user_books for select using (auth.uid() in (select id from public.profiles where is_admin = true));


-- Create subscription_plans table
create table public.subscription_plans (
    id uuid default extensions.uuid_generate_v4() primary key,
    name text not null,
    price numeric not null,
    period text not null, -- e.g., 'daily', 'weekly', 'monthly', 'yearly'
    features text[],
    active boolean default true not null,
    created_at timestamp with time zone default now() not null
);
alter table public.subscription_plans enable row level security;
create policy "Allow public read access to active plans" on public.subscription_plans for select using (active = true);
create policy "Allow admin full access to plans" on public.subscription_plans for all using (auth.uid() in (select id from public.profiles where is_admin = true)) with check (auth.uid() in (select id from public.profiles where is_admin = true));


-- Create transactions table
create table public.transactions (
    id uuid default extensions.uuid_generate_v4() primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    amount numeric not null,
    status text not null, -- 'pending', 'completed', 'failed'
    transaction_type text not null, -- 'purchase', 'subscription', 'top-up', 'donation'
    book_id uuid references public.books(id) on delete set null,
    subscription_plan_id uuid references public.subscription_plans(id) on delete set null,
    mpesa_code text,
    created_at timestamp with time zone default now() not null
);
alter table public.transactions enable row level security;
create policy "Allow users to view their own transactions" on public.transactions for select using (auth.uid() = user_id);
create policy "Allow admin full access to transactions" on public.transactions for all using (auth.uid() in (select id from public.profiles where is_admin = true));


-- Create devotionals table
create table public.devotionals (
    id uuid default extensions.uuid_generate_v4() primary key,
    message text not null,
    author_id uuid references public.profiles(id) on delete set null,
    scheduled_for timestamp with time zone,
    sent_at timestamp with time zone,
    created_at timestamp with time zone default now() not null
);
alter table public.devotionals enable row level security;
create policy "Allow public read access to sent devotionals" on public.devotionals for select using (sent_at is not null and sent_at <= now());
create policy "Allow admin full access to devotionals" on public.devotionals for all using (auth.uid() in (select id from public.profiles where is_admin = true)) with check (auth.uid() in (select id from public.profiles where is_admin = true));

-- Create notifications table
create table public.notifications (
    id uuid default extensions.uuid_generate_v4() primary key,
    title text not null,
    message text not null,
    target_audience text not null, -- e.g., 'all', 'purchased'
    created_by uuid references public.profiles(id) on delete set null,
    sent_at timestamp with time zone default now() not null
);
alter table public.notifications enable row level security;
create policy "Allow admin full access to notifications" on public.notifications for all using (auth.uid() in (select id from public.profiles where is_admin = true)) with check (auth.uid() in (select id from public.profiles where is_admin = true));

-- Create activity_logs table
create table public.activity_logs (
    id bigint generated by default as identity primary key,
    admin_id uuid not null references public.profiles(id) on delete cascade,
    action text not null,
    details text,
    timestamp timestamp with time zone default now() not null
);
alter table public.activity_logs enable row level security;
create policy "Allow admin read access to logs" on public.activity_logs for select using (auth.uid() in (select id from public.profiles where is_admin = true));
create policy "Allow admin to insert logs" on public.activity_logs for insert with check (auth.uid() = admin_id and auth.uid() in (select id from public.profiles where is_admin = true));

